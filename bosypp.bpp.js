const argv=process.argv;
const bpp=argv[2];
const fs=require("node:fs");
let code=fs.readFileSync(bpp,"utf8");

function lexer(code){const tokens=[];
let pos=0;
while(pos<code.length){let char=code[pos];
if(/\s/.test(char)){pos++;
continue;
}if(/[0-9]/.test(char)||(char==="-"&&/[0-9]/.test(code[pos+1]))){let start=pos;
pos++;
while(/[0-9]/.test(code[pos])||code[pos]==="x"||code[pos]==="b"){pos++;
}tokens.push(code.slice(start,pos));
continue;
}if(char=="/"&&code[pos+1]=="/"){pos+=2;
while(code[pos]!="\n"){pos++;
}pos++;
continue;
}if(char=="/"&&code[pos+1]=="*"){pos+=2;
while(code[pos]!="*"||code[pos+1]!="/"){pos++;
}pos+=2;
continue;
}if(char=="\""||char=="'"){pos++;
let value="";
while(pos<code.length&&code[pos]!==char){if(code[pos]==="\\"){pos++;
switch(code[pos]){case "\"":value+="\\\"";
break;
case "'":value+="\\'";
break;
case "n":value+="\\n";
break;
case "t":value+="\\t";
break;
case "r":value+="\\r";
break;
case "\\":value+="\\\\";
break;
default:value+="\\";
value+=code[pos];
break;
}pos++;
}else{value+=code[pos];
pos++;
}}pos++;
tokens.push(char+value+char);
continue;
}if(eval("/[\\\!\\\@\\\#\\\$\\\%\\\^\\\&\\\*\\\(\\\)\\\-\\\+\\\=\\\{\\\}\\\[\\\]\\\|\\\:\\\;\\\<\\\>\\\,\\\.\\\?\\\/]/.test(char)")){let value=char;
if((char==="!"||char==="="||char==="<"||char===">")&&code[pos+1]==="="){value+=code[++pos];
}pos++;
tokens.push(value);
continue;
}if(/[a-zA-Z_]/.test(char)){let start=pos;
while(/[a-zA-Z0-9_]/.test(code[pos])){pos++;
}tokens.push(code.slice(start,pos));
continue;
}tokens.push(char);
pos++;
}return tokens;
}let macros={};
let modules={};
let cmodule=undefined;
let usings=[];
function parser(toks,state=0){let ast=[];
while(toks.length){const tok=toks[0];
toks=toks.slice(1);
if(/[0-9]/.test(tok[0])||tok[0]==="-"&&/[0-9]/.test(tok[1])){ast.push({"type":"number","value":Number(tok)});
}else if (tok[0]==="\""||tok[0]==="'"){ast.push({"type":"string","value":tok.substr(1,tok.length-2)});
}else if (state===1&&tok===")"){break;
}else if (state===2&&tok==="}"){break;
}else if (tok==="("){const inner=parser(toks,1);
toks=inner.tokens;
ast.push({"type":"expr","value":inner.ast});
}else if (tok==="{"){const inner=parser(toks,2);
toks=inner.tokens;
ast.push({"type":"block","value":inner.ast});
}else{ast.push({"type":"word","value":tok});
}}return {"ast":ast,"tokens":toks};
}function compiler_ast(ast){let code="";
let currt=null;
if(ast.type){if (((ast.type)) === "expr") {{return {type:"expr",value:"("+compiler_ast(ast.value)+")"};
}}if (((ast.type)) === "block") {{return {type:"block",value:"{"+compiler_ast(ast.value)+"}"};
}}if (((ast.type)) === "string") {{return {type:"string",value:"\""+ast.value+"\""};
}}if (((ast.type)) === "number") {{return {type:"number",value:ast.value};
}}if (((ast.type)) === "word") {{return {type:"word",value:ast.value};
}}return undefined;
}if(ast&&ast.ast)ast=ast.ast;
for(let i=0;
i<ast.length;
++i){let obj=compiler_ast(ast[i]);
if(obj.type==="word"){if (((obj.value)) === "include") {{obj=ast[i+1];
if(obj.type!=="string"){console.log("Excepted <include \"\"> but got <include "+obj.value+">");
exit(1);
}code+="\n"+compiler_ast(parser(lexer(fs.readFileSync(obj.value,"utf8"))))+"\n";
i++;
continue;
}}if (((obj.value)) === "const") {{code+="const ";
continue;
}}if (((obj.value)) === "class") {{code+="class ";
continue;
}}if (((obj.value)) === "let") {{code+="let ";
continue;
}}if (((obj.value)) === "var") {{code+="let ";
continue;
}}if (((obj.value)) === ";") {{code+=";\n";
continue;
}}if (((obj.value)) === "{") {{code+="{\n";
continue;
}}if (((obj.value)) === "}") {{code+="}\n";
continue;
}}if (((obj.value)) === "case") {{code+="case ";
continue;
}}if (((obj.value)) === "return") {{code+="return ";
continue;
}}if (((obj.value)) === "fn") {{if(cmodule===undefined){code+="function ";
}else{modules[cmodule].push(ast[i+1].value);
code+=ast[i+1].value+": function";
i++;
}continue;
}}if (((obj.value)) === "using") {{usings.push(ast[i+1].value);
i++;
continue;
}}if (((obj.value)) === "elif") {{code+="else if ";
continue;
}}if (((obj.value)) === "ifdef") {{if(macros[ast[i+1].value]!==undefined){code+=compiler_ast(ast[i+2]).value;
}i+=2;
continue}}if (((obj.value)) === "ifndef") {{if(macros[ast[i+1].value]===undefined){code+=compiler_ast(ast[i+2]).value;
}i+=2;
continue}}if (((obj.value)) === "match") {{i++;
console.log(ast[i]);
const value=compiler_ast(ast[i]).value;
i++;
for(let j=0;
j<ast[i].value.length;
j+=2){const f=compiler_ast(ast[i].value[j]).value;
const d=ast[i].value[j+1];
console.log(f,d);
code+="if (("+value+") === "+f+") {"+compiler_ast(d).value+"}";
}continue;
}}if (((obj.value)) === "module") {{i++;
const name=compiler_ast(ast[i]).value;
i++;
cmodule=name;
modules[cmodule]=[];
code+="const "+name+" = "+compiler_ast(ast[i]).value+";";
cmodule=undefined;
continue;
}}if (((obj.value)) === "enum") {{i++;
console.log(ast[i]);
const name=compiler_ast(ast[i]).value;
i++;
if(cmodule===undefined){code+="// Enum ("+name+")\n";
code+="const "+name+" = {";
for(let j=0;
j<ast[i].value.length;
++j){const f=compiler_ast(ast[i].value[j]);
if(f.type=="word"){code+=f.value+": "+j+",";
code+=j+": \""+f.value+"\",";
}}code+="};";
}else{modules[cmodule].push(name);
code+="// Enum ("+name+")\n";
code+=name+": {";
for(let j=0;
j<ast[i].value.length;
++j){const f=compiler_ast(ast[i].value[j]);
if(f.type=="word"){code+=f.value+": "+j+",";
code+=j+": \""+f.value+"\",";
}}code+="},";
}continue;
}}if (((obj.value)) === "struct") {{i++;
const name=compiler_ast(ast[i]).value;
i++;
let fields=[];
for(let j=0;
j<ast[i].value.length;
++j){fields.push(compiler_ast(ast[i].value[j]).value);
}if(cmodule===undefined){code+="function "+name+"(";
}else{modules[cmodule].push(name);
code+=name+": function (";
}for(let j=0;
j<fields.length;
++j){code+="_"+fields[j];
if(j!=fields.length-1){code+=", ";
}}code+=") { return {";
for(let j=0;
j<fields.length;
++j){code+=fields[j]+": _"+fields[j];
if(j!=fields.length-1){code+=", ";
}}code+="}; }";
continue;
}}if (((obj.value)) === "def") {{const name=compiler_ast(ast[i+1]).value;
const expands=ast[i+2].value;
macros[name]=expands;
i+=2;
continue;
}}if (((obj.value)) === "undef") {{const name=compiler_ast(ast[i+1]).value;
macros[name]=undefined;
i++;
continue;
}}if(macros[obj.value]!==undefined){code+=compiler_ast(macros[obj.value]);
continue;
}}else if (obj.type==="string"){code+=obj.value;
continue;
}for(let j=0;
j<usings.length;
++j){if(modules[usings[i]]){console.log(modules[usings[i]],"'"+obj.value+"'",modules[usings[i]].indexOf(obj.value)!==-1);
if(modules[usings[i]].indexOf(obj.value)!==-1){code+=usings[i]+".";
break;
}}}code+=obj.value;
}return code;
}
const ast=parser(lexer(code));
console.log(ast);
fs.writeFileSync(bpp+".js",compiler_ast(ast));
