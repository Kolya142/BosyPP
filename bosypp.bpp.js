const argv  = process.argv;
const bpp  = argv[2];
const fs  = require("node:fs");
let code  = fs.readFileSync(bpp,"utf8");

"use strict";

function lexer(code) {const tokens  = [];
let pos  = 0;
while(pos<code.length){let char  = code[pos];
if(/\s/.test(char)){pos++;
continue;
}if(/[0-9]/.test(char)||(char==="-"&&/[0-9]/.test(code[pos+1]))){let start  = pos;
pos++;
while(/[0-9]/.test(code[pos])||code[pos]==="x"||code[pos]==="b"||code[pos]==="."){pos++;
}tokens.push(code.slice(start,pos));
continue;
}if(char==="/"&&code[pos+1]==="/"){pos+=2;
while(code[pos]!=="\n"){pos++;
}pos++;
continue;
}if(char==="/"&&code[pos+1]==="*"){pos+=2;
while(code[pos]!=="*"||code[pos+1]!=="/"){pos++;
}pos+=2;
continue;
}if(char==="\""||char==="'"){pos++;
let value  = "";
while(pos<code.length&&code[pos]!==char){if(code[pos]==="\\"){pos++;
switch(code[pos]){case "\"":value+="\\\"";
break;
case "'":value+="\\'";
break;
case "n":value+="\\n";
break;
case "t":value+="\\t";
break;
case "r":value+="\\r";
break;
case "\\":value+="\\\\";
break;
default:value+="\\";
value+=code[pos];
break;
}pos++;
}else {value+=code[pos];
pos++;
}}pos++;
tokens.push(char+value+char);
continue;
}if("!@#$%^&*()-+=_{}[]|:;<>,.?/\\".indexOf(char)!==-1){let value  = char;
if((char==="!"||char==="="||char==="<"||char===">"||char==="+"||char==="-"||char==="*"||char==="/")&&code[pos+1]==="="){value+=code[++pos];
}pos++;
tokens.push(value);
continue;
}if(/[a-zA-Z_]/.test(char)){let start  = pos;
while(/[a-zA-Z0-9_]/.test(code[pos])){pos++;
}tokens.push(code.slice(start,pos));
continue;
}tokens.push(char);
pos++;
}return tokens;
}

function parser(toks,state=0) {let ast  = [];
while(toks.length){const tok  = toks[0];
toks=toks.slice(1);
if(/[0-9]/.test(tok[0])||tok[0]==="-"&&/[0-9]/.test(tok[1])){ast.push({"type":"number","value":Number(tok)});
}else if (tok[0]==="\""||tok[0]==="'"){ast.push({"type":"string","value":tok.substr(1,tok.length-2)});
}else if (state===1&&tok===")"){break;
}else if (state===2&&tok==="}"){break;
}else if (tok==="("){const inner  = parser(toks,1);
toks=inner.tokens;
ast.push({"type":"expr","value":inner.ast});
}else if (tok==="{"){const inner  = parser(toks,2);
toks=inner.tokens;
ast.push({"type":"block","value":inner.ast});
}else {ast.push({"type":"word","value":tok});
}}return {"ast":ast,"tokens":toks};
}
let macros  = {};
let types  = {};
function Context(_type, _name) { return {type: _type, name: _name}; }function ContextFunction(_type, _name, _args, _ret) { return {type: _type, name: _name, args: _args, ret: _ret}; }function ContextStmt(_type, _name) { return {type: _type, name: _name}; }function ContextMatch(_type, _name, _testable) { return {type: _type, name: _name, testable: _testable}; }function SourceMap(_variables, _functions, _context, _return_type, _parent, _interfaces) { return {variables: _variables, functions: _functions, context: _context, return_type: _return_type, parent: _parent, interfaces: _interfaces}; }function Variable(_name, _type, _pvalue) { return {name: _name, type: _type, pvalue: _pvalue}; }function EaterResult(_i, _code, _sm) { return {i: _i, code: _code, sm: _sm}; }function eat_variable_define(ast,i,sm) {code=ast[i].value+" ";
i++;
if(ast[i].value===":"){sm.variables.push(Variable(ast[i-1].value,ast[i+1].value,null));
i+=2;
}if(ast[i].value!=="="){throw"Excepted = at variable definition";
}i++;
code+=" = ";
while(ast[i].value!==";"){code+=compiler_ast(ast[i],sm).value;
i++;
}code+=";\n";
return EaterResult(i,code,sm);
}function compiler_ast(ast,sm) {console.log(sm);
let code  = "";
if(ast.type){if (((ast.type)) === "expr") {{return {type:"expr",value:"("+compiler_ast(ast.value,sm).value+")"};
}}else if (((ast.type)) === "block") {{return {type:"block",value:"{"+compiler_ast(ast.value,sm).value+"}"};
}}else if (((ast.type)) === "string") {{return {type:"string",value:"\""+ast.value+"\""};
}}else if (((ast.type)) === "number") {{return {type:"number",value:ast.value};
}}else if (((ast.type)) === "word") {{return {type:"word",value:ast.value};
}}throw"Unknown ast type ("+ast.type+")";
}if(ast&&ast.ast)ast=ast.ast;
for(let i  = 0;
i<ast.length;
++i){let obj  = compiler_ast(ast[i],sm);
if(obj.type==="word"){if (((obj.value)) === "include") {{obj=ast[i+1];
if(obj.type!=="string"){console.log("Excepted <include \"\"> but got <include "+obj.value+">");
exit(1);
}const d  = compiler_ast(parser(lexer(fs.readFileSync(obj.value,"utf8"))),sm);
code+="\n"+d.value+"\n";
i++;
continue;
}}else if (((obj.value)) === "class") {{code+="class ";
continue;
}}else if (((obj.value)) === "extends") {{code+="extends ";
continue;
}}else if (((obj.value)) === "const") {{code+="const ";
i++;
const er  = eat_variable_define(ast,i,sm);
i=er.i;
code+=er.code;
sm=er.sm;
continue;
}}else if (((obj.value)) === "let") {{code+="let ";
i++;
const er  = eat_variable_define(ast,i,sm);
i=er.i;
code+=er.code;
sm=er.sm;
continue;
}}else if (((obj.value)) === "var") {{code+="let ";
i++;
const er  = eat_variable_define(ast,i,sm);
i=er.i;
code+=er.code;
sm=er.sm;
continue;
}}else if (((obj.value)) === "new") {{code+="new ";
continue;
}}else if (((obj.value)) === "case") {{code+="case ";
continue;
}}else if (((obj.value)) === "return") {{code+="return ";
continue;
}}else if (((obj.value)) === "fn") {{code+="function ";
code+=ast[i+1].value;
const csm  = SourceMap(sm.variables,sm.functions,ContextFunction("function",ast[i+1].value,null,null),sm.interfaces);
code+=compiler_ast(ast[i+2],csm).value+" ";
if(ast[i+3].value===">"){csm.context.return_type=ast[i+4].value;
i+=2;
}code+=compiler_ast(ast[i+3],csm).value;
i+=3;
continue;
}}else if (((obj.value)) === "elif") {{code+="else if ";
continue;
}}else if (((obj.value)) === "else") {{code+="else ";
continue;
}}else if (((obj.value)) === "ifdef") {{if(macros[ast[i+1].value]!==undefined){code+=compiler_ast(ast[i+2],sm).value;
}i+=2;
continue}}else if (((obj.value)) === "ifndef") {{if(macros[ast[i+1].value]===undefined){code+=compiler_ast(ast[i+2],sm).value;
}i+=2;
continue}}else if (((obj.value)) === "match") {{i++;
const value  = compiler_ast(ast[i],sm).value;
const csm  = SourceMap(sm.variables,sm.functions,ContextMatch("match",null,value),null,sm.interfaces);
i++;
for(let j  = 0;
j<ast[i].value.length;
j+=2){const f  = compiler_ast(ast[i].value[j],csm).value;
const d  = ast[i].value[j+1];
if(f==="_"){code+="else {"+compiler_ast(d,csm).value+"}";
}else {if(!j){code+="if ";
}else {code+="else if ";
}if(f==="if"){code+="("+compiler_ast(d,csm).value+") "+compiler_ast(ast[i].value[j+2],csm).value+"";
j++;
}else {code+="(("+value+") === "+f+") {"+compiler_ast(d,csm).value+"}";
}}}continue;
}}else if (((obj.value)) === "enum") {{i++;
const name  = compiler_ast(ast[i],sm).value;
i++;
code+="// Enum ("+name+")\n";
code+="const "+name+" = {";
for(let j  = 0;
j<ast[i].value.length;
++j){const f  = compiler_ast(ast[i].value[j],sm);
if(f.type==="word"){code+=f.value+": "+j+",";
code+=j+": \""+f.value+"\",";
}}code+="};";
continue;
}}else if (((obj.value)) === "struct") {{i++;
const name  = compiler_ast(ast[i],sm).value;
i++;
let fields  = [];
for(let j  = 0;
j<ast[i].value.length;
++j){fields.push(compiler_ast(ast[i].value[j],sm).value);
}code+="function "+name+"(";
for(let j  = 0;
j<fields.length;
++j){code+="_"+fields[j];
if(j!==fields.length-1){code+=", ";
}}code+=") { return {";
for(let j  = 0;
j<fields.length;
++j){code+=fields[j]+": _"+fields[j];
if(j!==fields.length-1){code+=", ";
}}code+="}; }";
continue;
}}else if (((obj.value)) === ";") {{code+=";\n";
continue;
}}else if (((obj.value)) === "{") {{code+="{\n";
continue;
}}else if (((obj.value)) === "}") {{code+="}\n";
continue;
}}else if (((obj.value)) === "def") {{const name  = compiler_ast(ast[i+1],sm).value;
const expands  = ast[i+2].value;
macros[name]=expands;
i+=2;
continue;
}}else if (((obj.value)) === "undef") {{const name  = compiler_ast(ast[i+1],sm).value;
macros[name]=undefined;
i++;
continue;
}}else if (((obj.value)) === "==") {{code+="===";
continue;
}}else if (((obj.value)) === "!=") {{code+="!==";
continue;
}}else if ((macros[obj.value]!==undefined)) {code+=compiler_ast(macros[obj.value],sm).value;
continue;
}else if ((obj.type==="number")) {code+=obj.value;
continue;
}}else if (obj.type==="string"){code+=obj.value;
continue;
}code+=obj.value;
}return {type:"code",value:code};
}
const ast  = parser(lexer(code));
fs.writeFileSync(bpp+".js",compiler_ast(ast,SourceMap([],[],ContextFunction("function","toplevel",null,null),null,null,[])).value);
