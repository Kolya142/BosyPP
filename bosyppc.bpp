def print (console.log)

fn lexer(code) {
    const tokens = [];
    let pos = 0;
    while (pos < code.length) {
        let char = code[pos];
        if (/\s/.test(char)) {
            pos++;
            continue;
        }
        if (/[0-9]/.test(char) || (char === '-' && /[0-9]/.test(code[pos + 1]))) {
            let start = pos;
            pos++;
            while (/[0-9]/.test(code[pos]) || code[pos] === 'x' || code[pos] === 'b') {
                pos++;
            }
            tokens.push(code.slice(start, pos));
            continue;
        }
        if (char == "/" && code[pos + 1] == "/") { // Test
            pos += 2;
            while (code[pos] != "\n") {
                pos++;
            }
            pos++;
            continue;
        }
        if (char == "/" && code[pos + 1] == "*") { /* Test */
            pos += 2;
            while (code[pos] != "*" || code[pos + 1] != "/") {
                pos++;
            }
            pos += 2;
            continue;
        }
        if (char == "\"" || char == "'") {
            pos++;
            let value = "";
            while (pos < code.length && code[pos] !== char) {
                if (code[pos] === '\\') {
                    pos++;
                    switch (code[pos]) {
                        case "\"": value += "\\\""; break;
                        case "'": value += "\\'"; break;
                        case 'n': value += '\\n'; break;
                        case 't': value += '\\t'; break;
                        case 'r': value += '\\r'; break;
                        case '\\': value += '\\\\'; break;
                        default: value += '\\'; value += code[pos]; break;
                    }
                    pos++;
                }
                else {
                    value += code[pos];
                    pos++;
                }
            }
            pos++;
            tokens.push(char + value + char);
            continue;
        }
        if (eval("/[\\\!\\\@\\\#\\\$\\\%\\\^\\\&\\\*\\\(\\\)\\\-\\\+\\\=\\\{\\\}\\\[\\\]\\\|\\\:\\\;\\\<\\\>\\\,\\\.\\\?\\\/]/.test(char)")) {
            let value = char;
            if ((char === '!' || char === '=' || char === '<' || char === '>') && code[pos + 1] === '=') {
                value += code[++pos];
            }
            pos++;
            tokens.push(value);
            continue;
        }
        if (/[a-zA-Z_]/.test(char)) {
            let start = pos;
            while (/[a-zA-Z0-9_]/.test(code[pos])) {
                pos++;
            }
            tokens.push(code.slice(start, pos));
            continue;
        }
        tokens.push(char);
        pos++;
    }
    return tokens;
}

let macros = {};
let modules = {};
let cmodule = undefined;
let usings = [];

fn parser(toks, state = 0) {
    let ast = [];
    while (toks.length) {
        const tok = toks[0];
        toks = toks.slice(1);
        if (/[0-9]/.test(tok[0]) || tok[0] === '-' && /[0-9]/.test(tok[1])) {
            ast.push({"type": "number", "value": Number(tok)});
        }
        elif (tok[0] === "\"" || tok[0] === "'") {
            ast.push({"type": "string", "value": tok.substr(1, tok.length - 2)});
        }
        elif (state === 1 && tok === ")") {
            break;
        }
        elif (state === 2 && tok === "}") {
            break;
        }
        elif (tok === "(") {
            const inner = parser(toks, 1);
            toks = inner.tokens;
            ast.push({"type": "expr", "value": inner.ast});
        }
        elif (tok === "{") {
            const inner = parser(toks, 2);
            toks = inner.tokens;
            ast.push({"type": "block", "value": inner.ast});
        }
        else {
            ast.push({"type": "word", "value": tok});
        }
    }
    return {"ast": ast, "tokens": toks};
}

fn compiler_ast(ast) {
    let code = "";
    let currt = null;
    if (ast.type) {
        match (ast.type) {
            "expr" {
                return {type:"expr", value:"(" + compiler_ast(ast.value) + ")"};
            }
            "block" {
                return {type:"block", value:"{" + compiler_ast(ast.value) + "}"};
            }
            "string" {
                return {type:"string", value:"\""+ast.value+"\""};
            }
            "number" {
                return {type:"number", value:ast.value};
            }
            "word" {
                return {type:"word", value:ast.value};
            }
        }
        return undefined;
    }
    if (ast && ast.ast) ast = ast.ast;
    for (let i = 0; i < ast.length; ++i) {
        let obj = compiler_ast(ast[i]);
        print(obj);
        if (obj.type === "word") {
            match (obj.value) {
                "include" {
                    obj = ast[i + 1];
                    if (obj.type !== "string") {
                        print("Excepted <include \"\"> but got <include " + obj.value + ">");
                        exit(1);
                    }
                    code += "\n" + compiler_ast(parser(lexer(fs.readFileSync(obj.value, 'utf8')))) + "\n";
                    i++;
                    continue;
                }
                "const" {
                    code += "const ";
                    continue;
                }
                "class" {
                    code += "class ";
                    continue;
                }
                "extends" {
                    code += "extends ";
                    continue;
                }
                "let" {
                    code += "let ";
                    continue;
                }
                "var" {
                    code += "let ";
                    continue;
                }
                ";" {
                    code += ";\n";
                    continue;
                }
                "{" {
                    code += "{\n";
                    continue;
                }
                "}" {
                    code += "}\n";
                    continue;
                }
                "case" {
                    code += "case ";
                    continue;
                }
                "return" {
                    code += "return ";
                    continue;
                }
                "fn" {
                    if (cmodule === undefined) {
                        code += "function ";
                    }
                    else {
                        modules[cmodule].push(ast[i + 1].value);
                        code += ast[i + 1].value + ": function ";
                        i++;
                    }
                    continue;
                }
                "using" {
                    usings.push(ast[i + 1].value);
                    i++;
                    continue;
                }
                "elif" {
                    code += "else if ";
                    continue;
                }
                "ifdef" {
                    if (macros[ast[i + 1].value] !== undefined) {
                        code += compiler_ast(ast[i + 2]).value;
                    }
                    i += 2;
                    continue
                }
                "ifndef" {
                    if (macros[ast[i + 1].value] === undefined) {
                        code += compiler_ast(ast[i + 2]).value;
                    }
                    i += 2;
                    continue
                }
                "match" {
                    i++;
                    print(ast[i]);
                    const value = compiler_ast(ast[i]).value;
                    i++;
                    for (let j = 0; j < ast[i].value.length; j += 2) {
                        const f = compiler_ast(ast[i].value[j]).value;
                        const d = ast[i].value[j+1];
                        print(f, d);
                        code += "if ((" + value + ") === " + f + ") {" + compiler_ast(d).value + "}";
                    }
                    continue;
                }
                "module" {
                    i++;
                    const name = compiler_ast(ast[i]).value;
                    i++;
                    cmodule = name;
                    modules[cmodule] = [];
                    code += "const " + name + " = " + compiler_ast(ast[i]).value + ";";
                    print(modules[cmodule]);
                    cmodule = undefined;
                    continue;
                }
                "enum" {
                    i++;
                    print(ast[i]);
                    const name = compiler_ast(ast[i]).value;
                    i++;
                    if (cmodule === undefined) {
                        code += "// Enum (" + name + ")\n";
                        code += "const " + name + " = {";
                        for (let j = 0; j < ast[i].value.length; ++j) {
                            const f = compiler_ast(ast[i].value[j]);
                            if (f.type == "word") {
                                code += f.value + ": " + j + ",";
                                code += j + ": \"" + f.value + "\",";
                            }
                        }
                        code += "};";
                    }
                    else {
                        modules[cmodule].push(name);
                        code += "// Enum (" + name + ")\n";
                        code += name + ": {";
                        for (let j = 0; j < ast[i].value.length; ++j) {
                            const f = compiler_ast(ast[i].value[j]);
                            if (f.type == "word") {
                                code += f.value + ": " + j + ",";
                                code += j + ": \"" + f.value + "\",";
                            }
                        }
                        code += "},";
                    }
                    continue;
                }
                "struct" {
                    i++;
                    const name = compiler_ast(ast[i]).value;
                    i++;
                    let fields = [];
                    for (let j = 0; j < ast[i].value.length; ++j) {
                        fields.push(compiler_ast(ast[i].value[j]).value);
                    }
                    if (cmodule === undefined) {
                        code += "function " + name + "(";
                    }
                    else {
                        modules[cmodule].push(name);
                        code += name + ": function (";
                    }
                    for (let j = 0; j < fields.length; ++j) {
                        code += "_" + fields[j];
                        if (j != fields.length - 1) {
                            code += ", ";
                        }
                    }
                    code += ") { return {";
                    for (let j = 0; j < fields.length; ++j) {
                        code += fields[j] + ": _" + fields[j];
                        if (j != fields.length - 1) {
                            code += ", ";
                        }
                    }
                    code += "}; }";
                    continue;
                }
                "def" {
                    const name = compiler_ast(ast[i + 1]).value;
                    const expands = ast[i + 2].value;
                    macros[name] = expands;
                    i += 2;
                    continue;
                }
                "undef" {
                    const name = compiler_ast(ast[i + 1]).value;
                    macros[name] = undefined;
                    i++;
                    continue;
                }
            }
            if (macros[obj.value] !== undefined) {
                code += compiler_ast(macros[obj.value]);
                continue;
            }
        }
        elif (obj.type === "string") {
            code += obj.value;
            continue;
        }
        for (let j = 0; j < usings.length; ++j) {
            if (modules[usings[j]]) {
                print(modules[usings[j]], "'"+obj.value+"'", modules[usings[j]].indexOf(obj.value) !== -1);
                if (modules[usings[j]].indexOf(obj.value) !== -1) {
                    code += usings[j] + ".";
                    break;
                }
            }
        }
        code += obj.value;
    }
    return code;
}
