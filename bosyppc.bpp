"use strict";
def print (console.log)

include "lexer.bpp"
include "parser.bpp"

let macros = {};
let types = {};

fn compiler_ast(ast) {
    let code = "";
    let currt = null;
    if (ast.type) {
        match (ast.type) {
            "expr" {
                return {type:"expr", value:"(" + compiler_ast(ast.value) + ")"};
            }
            "block" {
                return {type:"block", value:"{" + compiler_ast(ast.value) + "}"};
            }
            "string" {
                return {type:"string", value:"\""+ast.value+"\""};
            }
            "number" {
                return {type:"number", value:ast.value};
            }
            "word" {
                return {type:"word", value:ast.value};
            }
        }
        return undefined;
    }
    if (ast && ast.ast) ast = ast.ast;
    for (let i = 0; i < ast.length; ++i) {
        let obj = compiler_ast(ast[i]);
        ifdef DEBUG {print(obj);}
        if (obj.type == "word") {
            match (obj.value) {
                "include" {
                    obj = ast[i + 1];
                    if (obj.type != "string") {
                        print("Excepted <include \"\"> but got <include " + obj.value + ">");
                        exit(1);
                    }
                    code += "\n" + compiler_ast(parser(lexer(fs.readFileSync(obj.value, 'utf8')))) + "\n";
                    i++;
                    continue;
                }
                "class" {
                    code += "class ";
                    continue;
                }
                "extends" {
                    code += "extends ";
                    continue;
                }
                "const" {
                    code += "const ";
                    continue;
                }
                "let" {
                    code += "let ";
                    continue;
                }
                "var" {
                    code += "let ";
                    continue;
                }
                "case" {
                    code += "case ";
                    continue;
                }
                "return" {
                    code += "return ";
                    continue;
                }
                "fn" {
                    code += "function ";
                    continue;
                }
                "elif" {
                    code += "else if ";
                    continue;
                }
		"else" {
		    code += "else ";
		    continue;
		}
                "ifdef" {
                    if (macros[ast[i + 1].value] != undefined) {
                        code += compiler_ast(ast[i + 2]).value;
                    }
                    i += 2;
                    continue
                }
                "ifndef" {
                    if (macros[ast[i + 1].value] == undefined) {
                        code += compiler_ast(ast[i + 2]).value;
                    }
                    i += 2;
                    continue
                }
                "match" {
                    i++;
                    const value = compiler_ast(ast[i]).value;
                    i++;
                    for (let j = 0; j < ast[i].value.length; j += 2) {
                        const f = compiler_ast(ast[i].value[j]).value;
                        const d = ast[i].value[j+1];
                        if (f == "_") {
                            code += "else {" + compiler_ast(d).value + "}";
                        }
                        else {
			    if (!j) {
			        code += "if ";
			    }
			    else {
			        code += "else if ";
			    }
                            code += "((" + value + ") === " + f + ") {" + compiler_ast(d).value + "}";
                        }
                    }
                    continue;
                }
                "enum" {
                    i++;
                    const name = compiler_ast(ast[i]).value;
                    i++;
                    code += "// Enum (" + name + ")\n";
                    code += "const " + name + " = {";
                    for (let j = 0; j < ast[i].value.length; ++j) {
                        const f = compiler_ast(ast[i].value[j]);
                        if (f.type == "word") {
                            code += f.value + ": " + j + ",";
                            code += j + ": \"" + f.value + "\",";
                        }
                    }
                    code += "};";
                    continue;
                }
                "struct" {
                    i++;
                    const name = compiler_ast(ast[i]).value;
                    i++;
                    let fields = [];
                    for (let j = 0; j < ast[i].value.length; ++j) {
                        fields.push(compiler_ast(ast[i].value[j]).value);
                    }
                    code += "function " + name + "(";
                    for (let j = 0; j < fields.length; ++j) {
                        code += "_" + fields[j];
                        if (j != fields.length - 1) {
                            code += ", ";
                        }
                    }
                    code += ") { return {";
                    for (let j = 0; j < fields.length; ++j) {
                        code += fields[j] + ": _" + fields[j];
                        if (j != fields.length - 1) {
                            code += ", ";
                        }
                    }
                    code += "}; }";
                    continue;
                }
                ";" {
                    code += ";\n";
                    continue;
                }
                "{" {
                    code += "{\n";
                    continue;
                }
                "}" {
                    code += "}\n";
                    continue;
                }
                "def" {
                    const name = compiler_ast(ast[i + 1]).value;
                    const expands = ast[i + 2].value;
                    macros[name] = expands;
                    i += 2;
                    continue;
                }
                "undef" {
                    const name = compiler_ast(ast[i + 1]).value;
                    macros[name] = undefined;
                    i++;
                    continue;
                }
		"==" {
		     code += "===";
		     continue;
		}
		"!=" {
		     code += "!==";
		     continue;
		}
		_ {
		    if (macros[obj.value] != undefined) {
		        code += compiler_ast(macros[obj.value]);
		        continue;
		    }
		}
            }
        }
        elif (obj.type == "string") {
            code += obj.value;
            continue;
        }
        code += obj.value;
    }
    return code;
}
